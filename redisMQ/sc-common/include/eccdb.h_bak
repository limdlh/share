/*
 Support simple db operation,such as insert,update and  query.At the end will support MySQL,DB2,Oracle,ete different mainly databases,but currently only support MySQL.

 @Author Shan Jinlai
 @Date 03/06/2008

 Author   (MM/DD/YYYY)  modified   
 ylzhang   01/05/2013   add Oracle interface
 */
#ifndef ECCDB_H
#define ECCDB_H

#include <string>
#include <queue>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

using namespace std;

typedef unsigned char BYTE;

enum DBTYPE {
	DB_MYSQL
};

class ECCDBException {
	string exceptionMessage;
public:
	ECCDBException(string message) :
			exceptionMessage(message) {
	}
	;

	string getExceptionMessage() {
		return exceptionMessage;
	}
};
class ECCResultSet {
public:
	string tableName;
	int field_count;
	string* fields;

	int row_count;
	string** rows; // row data use string to store;


	string query; //store the sql query statement producing this result set

	int cursor; //row index
private:
	int nameToIndex(string field_name);
	string stringToUpper(string str);
	string exceptionMessage(int field_index){
		char buffer[256];
		memset(buffer, 0, 256);
		if (cursor < 0 || cursor >= row_count) {
			sprintf(
				buffer,
				"cursor out of bound where fetch data.cursor:%d,total row count:%d",
				cursor, row_count);
		}else {
			sprintf(
				buffer,
				"field index out of bound where fetch data.field_index:%d,total field count:%d",
				field_index, field_count);
		}
		return buffer;
	}
public:
	int getFieldCount() {
		return field_count;
	}
	;
	string getFieldName(int index) {
		if (index >= 0 && index < field_count)
			return fields[index];
		else
			return "";
	}
	int getRowCount() {
		return row_count;
	}
	;
	string getTableName() {
		return tableName;
	}
	;
	string getQuery() {
		return query;
	}
	;

	void first() {
		cursor = 0;
	}
	; //move cursor to first row;
	void next() {
		if (cursor < (row_count - 1))
			cursor++;
	}
	; //move cursor to next row;
	void last() {
		cursor = row_count - 1;
	}
	; //move cursor to last row;

	int getIntValue(int field_index);
	int getIntValue(string field_name);

	float getFloatValue(int field_index);
	float getFloatValue(string filed_name);

	double getDoubleValue(int field_index);
	double getDoubleValue(string field_name);

	BYTE* getBytesValue(int field_index);
	BYTE* getBytesValue(string field_name);

	string getStringValue(int field_index);
	string getStringValue(string field_name);

	bool getBoolValue(int field_index);
	bool getBoolValue(string field_name);

	ECCResultSet();
	~ECCResultSet();
};
class DBI {
public:
	virtual int EXEC_UPDATE(string sqlstr) {
			return true;
	}
	;
	virtual ECCResultSet* EXEC_SELECT(string sqlstr) {
			return NULL;
	}
	;
	virtual int getResultSetCount(){
		return 0;
	}
	virtual void freeResultSet() {
	}
	;
	virtual bool setAutoCommit(bool autoCommit) {
			return true;
	}
	virtual bool commit(){
		return true;
	}
	virtual bool rollback(){
		return true;
	}
	;
	DBI() {
	}
	;
	virtual ~DBI() {
	}
	;
};
class ECCDB {
	DBTYPE _dbtype;
	DBI *dbi;
	string _hostName, _userName, _passWord, _dbName;
	unsigned short _port;
	queue <string > sqlQueue;
	int sqlCount;
	pthread_mutex_t mutex;
	pthread_t hPollThread;
	pthread_cond_t hasAsyncUpdate;
	pthread_mutex_t async_mutex;

	public:
	ECCDB(string hostname,unsigned short port,string username,string password,string dbname,string dbtype);
	ECCDB(const ECCDB & db);
	~ECCDB();
	void switchHost(const string & hostName);
	string curHost()const{return _hostName;}
	int EXEC_UPDATE(string sqlstr);
	bool EXEC_UPDATE_ASYNC(string sqlstr);
	ECCResultSet* EXEC_SELECT(string sqlstr);
	int getResultSetCount();
	void freeResultSet();
	bool setAutoCommit(bool autoCommit);
	void asyncProcess(void *lpCmdLine);
	int getQueueLength() {return sqlCount;}
	bool commit();
	bool rollback();

private:
	void initAsyncUpdate();
};
#endif
